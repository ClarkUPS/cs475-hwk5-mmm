#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <time.h>
#include <string.h>
#include <stdio.h>
#include <pthread.h>
#include "mmm.h"



/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */
void mmm_init()
{
	srand(time(NULL));

	//Wish I could genaralize this block!

	//For Matrix 1
	int a; //Loop var for all loops
	int b; //Also loop var for all loops
	matrixOne = (double **) malloc(sizeof (double*) *matrixSize); 
	for(a = 0; a < matrixSize; a++){
		matrixOne[a] = (double *) malloc(sizeof (double) *matrixSize);
	}
	
	for(a = 0; a < matrixSize; a++){
		for(b = 0; b < matrixSize; b++){
			matrixOne[a][b] = rand() % 100;
		}
	}
	
	//For Matrix 2
	matrixTwo = (double **) malloc(sizeof (double*) *matrixSize); 
	for(a = 0; a < matrixSize; a++){
		matrixTwo[a] = (double *) malloc(sizeof (double) *matrixSize);
	}
	
	for(a = 0; a < matrixSize; a++){
		for(b = 0; b < matrixSize; b++){
			matrixTwo[a][b] = rand() % 100;
		}
	}

	//Allocate Space for Matrix Product
	
	S_matrixProduct = (double **) malloc(sizeof (double*) *matrixSize); 
	for(a = 0; a < matrixSize; a++){
		S_matrixProduct[a] = (double *) malloc(sizeof (double) *matrixSize);
	}
	P_matrixProduct = (double **) malloc(sizeof (double*) *matrixSize); 
	for(a = 0; a < matrixSize; a++){
		P_matrixProduct[a] = (double *) malloc(sizeof (double) *matrixSize);
	}

}

	//Genarazation Never
// void malMatrix(double **matrix){
// 	matrix = (double **) malloc(sizeof (double*) *matrixSize); 
// 	int a;
// 	for(a = 0; a < matrixSize; a++){
// 		matrix[a] = (double *) malloc(sizeof (double) *matrixSize);
// 	}
// }


// void rNumToMatrix(double **matrix){
// 	srand(time(NULL)); //set seeded matrix time!

// 	int a;
// 	int b;
// 	for(a = 0; a < matrixSize; a++){
// 		for(b = 0; b < matrixSize; b++){
// 			matrix[a][b] = rand();			
// 		}
// 	}
// }


/**
 * Reset a given matrix to zeroes
 */
void mmm_reset(double **matrix)
{
	int a;
	int b;
	for (a = 0; a < matrixSize; a++){
		for(b = 0; b < matrixSize; b++){
			matrix[a][b] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	int a;
	for(a = 0; a < matrixSize; a++){
		free(matrixOne[a]);
	}
	free(matrixOne);
	
	for(a = 0; a < matrixSize; a++){
		free(matrixTwo[a]);
	}
	free(matrixTwo);
	
	for(a = 0; a < matrixSize; a++){
		free(S_matrixProduct[a]);
	}
	free(S_matrixProduct);
	
	for(a = 0; a < matrixSize; a++){
		free(P_matrixProduct[a]);
	}
	free(P_matrixProduct);
}

/**
 * Sequential MMM
 */
void mmm_seq()
{
	int a;
	int b;
	int c;
	for(a = 0; a < matrixSize; a++){
		for(b = 0; b < matrixSize; b++){
			double product = 0;
			for(c = 0; c < matrixSize; c++){
				product += (matrixOne[a][c] * matrixTwo[c][b]);
			}
			S_matrixProduct[a][b] = product;
		}
	}
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args)
{
	thread_args *params = (thread_args *)args;
	
	// TODO - code to perform parallel MMM
	int a;
	int b;
	int c;
	for(a = params->firstRow; a < params->LastRow; a++){
		for(b = 0; b < matrixSize; b++){
			double product = 0;
			for(c = 0; c < matrixSize; c++){
				product += (matrixOne[a][c] * matrixTwo[c][b]);
			}
			P_matrixProduct[a][b] = product;
		}
	}	
	return NULL;
}


void parallel(){
	pthread_t threads[threadCount];
	thread_args args[threadCount]; //arguments for each of the threads

	int rowsEach = matrixSize/threadCount;//number of rows per thread
	int rowNum = 0; //current row

	//ERROR PRONE
	// if(rowsEach == 0){
	// 	rowsEach = 1;
	// }

	
	int i;
	for(i = 0; i < threadCount; i++){

		args[i].tid = i; //set the thread number
		args[i].firstRow = rowNum;
		
		rowNum += rowsEach;
		//Make sure that the last thread takes care of the final rows should the number of rows not be divisable by the number of threads!
		
		if(i == threadCount-1){
			args[i].LastRow = matrixSize;
		}else{
			args[i].LastRow = rowNum;
		}
		
		// if(!(rowNum > matrixSize)){
			pthread_create(&threads[i], NULL, mmm_par, &args[i]);
		//}
		
		
	}
	
	//reaping!
	int j;
	for(j = 0; j < threadCount; j++){
		pthread_join(threads[j], NULL);
	}	
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 */
double mmm_verify()
{
	double error;
	
	int a;
	int b;
	for(a = 0; a < matrixSize; a++){
		for(b = 0; b < matrixSize; b++){
			error += fabs(P_matrixProduct[a][b] - S_matrixProduct[a][b]);
		}
	}
	return error;
}


void printMatrix(double **matrix){
	int a;
	int b;
	for(a = 0; a < matrixSize; a++){
		for(b = 0; b < matrixSize; b++){
			printf("%f, ", matrix[a][b]);
		}
		printf("\n");
	}
}

